// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Package nearsight provides implementations of a bounded stack data structure.
package nearsight

import (
	"gonum.org/v1/gonum/mat"
	"gonum.org/v1/gonum/spatial/r3"
)

// MatVecDenseStack stores a bounded stack of MatVecDenses. The capacity is specified at construction time.
// When an element is pushed while the stack is at capacity, the new element acquires index 0; all
// old elements migrate to indices 1, 2, ...; and the oldest element is discarded.
type MatVecDenseStack interface {
	// Push adds the element to the front of the stack (index 0) and pushes all existing elements back one index
	Push(value mat.VecDense)
	// At gets the element at the given index [0 newest..Len() oldest)
	At(index int) mat.VecDense

	// Len returns the number of elements stored in the stack (less than or equal to Cap())
	Len() int
	// Cap returns the maximum number of elements that may be stored at once
	Cap() int

	// AsSlice returns the backing slice, for the purpose of iterating the whole stack
	AsSlice() []mat.VecDense
}

// enforce compliance of Ptr implementation
var _ MatVecDenseStack = (*PtrMatVecDenseStack)(nil)

// enforce compliance of COW implementation
var _ MatVecDenseStack = (*COWMatVecDenseStack)(nil)

// NewMatVecDenseStack returns an initialized MatVecDenseStack with the preferred backing implementation
func NewMatVecDenseStack(capacity int) MatVecDenseStack {
	return NewPtrMatVecDenseStack(capacity)
}

// Package nearsight provides implementations of a bounded stack data structure.

// R3VecStack stores a bounded stack of R3Vecs. The capacity is specified at construction time.
// When an element is pushed while the stack is at capacity, the new element acquires index 0; all
// old elements migrate to indices 1, 2, ...; and the oldest element is discarded.
type R3VecStack interface {
	// Push adds the element to the front of the stack (index 0) and pushes all existing elements back one index
	Push(value r3.Vec)
	// At gets the element at the given index [0 newest..Len() oldest)
	At(index int) r3.Vec

	// Len returns the number of elements stored in the stack (less than or equal to Cap())
	Len() int
	// Cap returns the maximum number of elements that may be stored at once
	Cap() int

	// AsSlice returns the backing slice, for the purpose of iterating the whole stack
	AsSlice() []r3.Vec
}

// enforce compliance of Ptr implementation
var _ R3VecStack = (*PtrR3VecStack)(nil)

// enforce compliance of COW implementation
var _ R3VecStack = (*COWR3VecStack)(nil)

// NewR3VecStack returns an initialized R3VecStack with the preferred backing implementation
func NewR3VecStack(capacity int) R3VecStack {
	return NewPtrR3VecStack(capacity)
}

// Package nearsight provides implementations of a bounded stack data structure.

// Float64Stack stores a bounded stack of Float64s. The capacity is specified at construction time.
// When an element is pushed while the stack is at capacity, the new element acquires index 0; all
// old elements migrate to indices 1, 2, ...; and the oldest element is discarded.
type Float64Stack interface {
	// Push adds the element to the front of the stack (index 0) and pushes all existing elements back one index
	Push(value float64)
	// At gets the element at the given index [0 newest..Len() oldest)
	At(index int) float64

	// Len returns the number of elements stored in the stack (less than or equal to Cap())
	Len() int
	// Cap returns the maximum number of elements that may be stored at once
	Cap() int

	// AsSlice returns the backing slice, for the purpose of iterating the whole stack
	AsSlice() []float64
}

// enforce compliance of Ptr implementation
var _ Float64Stack = (*PtrFloat64Stack)(nil)

// enforce compliance of COW implementation
var _ Float64Stack = (*COWFloat64Stack)(nil)

// NewFloat64Stack returns an initialized Float64Stack with the preferred backing implementation
func NewFloat64Stack(capacity int) Float64Stack {
	return NewPtrFloat64Stack(capacity)
}
