// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package nearsight

import (
	"gonum.org/v1/gonum/mat"
	"gonum.org/v1/gonum/spatial/r3"
)

type PtrMatVecDenseStack struct {
	data      []mat.VecDense
	headIndex int
}

func NewPtrMatVecDenseStack(size int) *PtrMatVecDenseStack {
	s := PtrMatVecDenseStack{
		data:      make([]mat.VecDense, 0, size),
		headIndex: -1,
	}
	return &s
}

func (s *PtrMatVecDenseStack) Push(value mat.VecDense) {
	s.headIndex = (s.headIndex + 1) % cap(s.data)
	switch {
	case len(s.data) <= s.headIndex:
		s.data = append(s.data, value)
	default:
		s.data[s.headIndex] = value
	}
}

func (s *PtrMatVecDenseStack) At(index int) mat.VecDense {
	realIndex := (-index + s.headIndex + cap(s.data)) % cap(s.data)
	return s.data[realIndex]
}

func (s *PtrMatVecDenseStack) Cap() int {
	return cap(s.data)
}

func (s *PtrMatVecDenseStack) Len() int {
	return len(s.data)
}

func (s *PtrMatVecDenseStack) AsSlice() []mat.VecDense {
	return s.data
}

type PtrR3VecStack struct {
	data      []r3.Vec
	headIndex int
}

func NewPtrR3VecStack(size int) *PtrR3VecStack {
	s := PtrR3VecStack{
		data:      make([]r3.Vec, 0, size),
		headIndex: -1,
	}
	return &s
}

func (s *PtrR3VecStack) Push(value r3.Vec) {
	s.headIndex = (s.headIndex + 1) % cap(s.data)
	switch {
	case len(s.data) <= s.headIndex:
		s.data = append(s.data, value)
	default:
		s.data[s.headIndex] = value
	}
}

func (s *PtrR3VecStack) At(index int) r3.Vec {
	realIndex := (-index + s.headIndex + cap(s.data)) % cap(s.data)
	return s.data[realIndex]
}

func (s *PtrR3VecStack) Cap() int {
	return cap(s.data)
}

func (s *PtrR3VecStack) Len() int {
	return len(s.data)
}

func (s *PtrR3VecStack) AsSlice() []r3.Vec {
	return s.data
}

type PtrFloat64Stack struct {
	data      []float64
	headIndex int
}

func NewPtrFloat64Stack(size int) *PtrFloat64Stack {
	s := PtrFloat64Stack{
		data:      make([]float64, 0, size),
		headIndex: -1,
	}
	return &s
}

func (s *PtrFloat64Stack) Push(value float64) {
	s.headIndex = (s.headIndex + 1) % cap(s.data)
	switch {
	case len(s.data) <= s.headIndex:
		s.data = append(s.data, value)
	default:
		s.data[s.headIndex] = value
	}
}

func (s *PtrFloat64Stack) At(index int) float64 {
	realIndex := (-index + s.headIndex + cap(s.data)) % cap(s.data)
	return s.data[realIndex]
}

func (s *PtrFloat64Stack) Cap() int {
	return cap(s.data)
}

func (s *PtrFloat64Stack) Len() int {
	return len(s.data)
}

func (s *PtrFloat64Stack) AsSlice() []float64 {
	return s.data
}
