// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package nearsight

import (
	"gonum.org/v1/gonum/mat"
	"gonum.org/v1/gonum/spatial/r3"
)

type COWMatVecDenseStack []mat.VecDense

func NewCOWMatVecDenseStack(size int) *COWMatVecDenseStack {
	s := COWMatVecDenseStack(make([]mat.VecDense, 0, size))
	return &s
}

func (s *COWMatVecDenseStack) Push(value mat.VecDense) {
	// store of append needs pointer semantics to modify slice header
	// so I used pointer semantics everywhere to avoid two symbols for the same thing
	// but pointer semantics are ugly idk
	switch {
	case len(*s) == 0:
		*s = append(*s, value)
	case len(*s) < cap(*s):
		*s = append(*s, value)
		copy((*s)[1:], *s)
		(*s)[0] = value
	default:
		copy((*s)[1:], *s)
		(*s)[0] = value
	}
}

func (s *COWMatVecDenseStack) At(index int) mat.VecDense {
	return (*s)[index]
}

func (s *COWMatVecDenseStack) Cap() int {
	return cap(*s)
}

func (s *COWMatVecDenseStack) Len() int {
	return len(*s)
}

func (s *COWMatVecDenseStack) AsSlice() []mat.VecDense {
	return *s
}

type COWR3VecStack []r3.Vec

func NewCOWR3VecStack(size int) *COWR3VecStack {
	s := COWR3VecStack(make([]r3.Vec, 0, size))
	return &s
}

func (s *COWR3VecStack) Push(value r3.Vec) {
	// store of append needs pointer semantics to modify slice header
	// so I used pointer semantics everywhere to avoid two symbols for the same thing
	// but pointer semantics are ugly idk
	switch {
	case len(*s) == 0:
		*s = append(*s, value)
	case len(*s) < cap(*s):
		*s = append(*s, value)
		copy((*s)[1:], *s)
		(*s)[0] = value
	default:
		copy((*s)[1:], *s)
		(*s)[0] = value
	}
}

func (s *COWR3VecStack) At(index int) r3.Vec {
	return (*s)[index]
}

func (s *COWR3VecStack) Cap() int {
	return cap(*s)
}

func (s *COWR3VecStack) Len() int {
	return len(*s)
}

func (s *COWR3VecStack) AsSlice() []r3.Vec {
	return *s
}

type COWFloat64Stack []float64

func NewCOWFloat64Stack(size int) *COWFloat64Stack {
	s := COWFloat64Stack(make([]float64, 0, size))
	return &s
}

func (s *COWFloat64Stack) Push(value float64) {
	// store of append needs pointer semantics to modify slice header
	// so I used pointer semantics everywhere to avoid two symbols for the same thing
	// but pointer semantics are ugly idk
	switch {
	case len(*s) == 0:
		*s = append(*s, value)
	case len(*s) < cap(*s):
		*s = append(*s, value)
		copy((*s)[1:], *s)
		(*s)[0] = value
	default:
		copy((*s)[1:], *s)
		(*s)[0] = value
	}
}

func (s *COWFloat64Stack) At(index int) float64 {
	return (*s)[index]
}

func (s *COWFloat64Stack) Cap() int {
	return cap(*s)
}

func (s *COWFloat64Stack) Len() int {
	return len(*s)
}

func (s *COWFloat64Stack) AsSlice() []float64 {
	return *s
}
